{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/BokehShader2.js"],
  "sourcesContent": ["import {\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * Depth-of-field shader with bokeh\r\n * ported from GLSL shader by Martins Upitis\r\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\r\n *\r\n * Requires #define RINGS and SAMPLES integers\r\n */\r\nconst BokehShader = {\r\n\r\n\tname: 'BokehShader',\r\n\r\n\tuniforms: {\r\n\r\n\t\t'textureWidth': { value: 1.0 },\r\n\t\t'textureHeight': { value: 1.0 },\r\n\r\n\t\t'focalDepth': { value: 1.0 },\r\n\t\t'focalLength': { value: 24.0 },\r\n\t\t'fstop': { value: 0.9 },\r\n\r\n\t\t'tColor': { value: null },\r\n\t\t'tDepth': { value: null },\r\n\r\n\t\t'maxblur': { value: 1.0 },\r\n\r\n\t\t'showFocus': { value: 0 },\r\n\t\t'manualdof': { value: 0 },\r\n\t\t'vignetting': { value: 0 },\r\n\t\t'depthblur': { value: 0 },\r\n\r\n\t\t'threshold': { value: 0.5 },\r\n\t\t'gain': { value: 2.0 },\r\n\t\t'bias': { value: 0.5 },\r\n\t\t'fringe': { value: 0.7 },\r\n\r\n\t\t'znear': { value: 0.1 },\r\n\t\t'zfar': { value: 100 },\r\n\r\n\t\t'noise': { value: 1 },\r\n\t\t'dithering': { value: 0.0001 },\r\n\t\t'pentagon': { value: 0 },\r\n\r\n\t\t'shaderFocus': { value: 1 },\r\n\t\t'focusCoords': { value: new Vector2() }\r\n\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tuniform sampler2D tColor;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform float textureWidth;\r\n\t\tuniform float textureHeight;\r\n\r\n\t\tuniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\r\n\t\tuniform float focalLength; //focal length in mm\r\n\t\tuniform float fstop; //f-stop value\r\n\t\tuniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\r\n\r\n\t\t/*\r\n\t\tmake sure that these two values are the same for your camera, otherwise distances will be wrong.\r\n\t\t*/\r\n\r\n\t\tuniform float znear; // camera clipping start\r\n\t\tuniform float zfar; // camera clipping end\r\n\r\n\t\t//------------------------------------------\r\n\t\t//user variables\r\n\r\n\t\tconst int samples = SAMPLES; //samples on the first ring\r\n\t\tconst int rings = RINGS; //ring count\r\n\r\n\t\tconst int maxringsamples = rings * samples;\r\n\r\n\t\tuniform bool manualdof; // manual dof calculation\r\n\t\tfloat ndofstart = 1.0; // near dof blur start\r\n\t\tfloat ndofdist = 2.0; // near dof blur falloff distance\r\n\t\tfloat fdofstart = 1.0; // far dof blur start\r\n\t\tfloat fdofdist = 3.0; // far dof blur falloff distance\r\n\r\n\t\tfloat CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\r\n\r\n\t\tuniform bool vignetting; // use optical lens vignetting\r\n\r\n\t\tfloat vignout = 1.3; // vignetting outer border\r\n\t\tfloat vignin = 0.0; // vignetting inner border\r\n\t\tfloat vignfade = 22.0; // f-stops till vignete fades\r\n\r\n\t\tuniform bool shaderFocus;\r\n\t\t// disable if you use external focalDepth value\r\n\r\n\t\tuniform vec2 focusCoords;\r\n\t\t// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\r\n\t\t// if center of screen use vec2(0.5, 0.5);\r\n\r\n\t\tuniform float maxblur;\r\n\t\t//clamp value of max blur (0.0 = no blur, 1.0 default)\r\n\r\n\t\tuniform float threshold; // highlight threshold;\r\n\t\tuniform float gain; // highlight gain;\r\n\r\n\t\tuniform float bias; // bokeh edge bias\r\n\t\tuniform float fringe; // bokeh chromatic aberration / fringing\r\n\r\n\t\tuniform bool noise; //use noise instead of pattern for sample dithering\r\n\r\n\t\tuniform float dithering;\r\n\r\n\t\tuniform bool depthblur; // blur the depth buffer\r\n\t\tfloat dbsize = 1.25; // depth blur size\r\n\r\n\t\t/*\r\n\t\tnext part is experimental\r\n\t\tnot looking good with small sample and ring count\r\n\t\tlooks okay starting from samples = 4, rings = 4\r\n\t\t*/\r\n\r\n\t\tuniform bool pentagon; //use pentagon as bokeh shape?\r\n\t\tfloat feather = 0.4; //pentagon shape feather\r\n\r\n\t\t//------------------------------------------\r\n\r\n\t\tfloat penta(vec2 coords) {\r\n\t\t\t//pentagonal shape\r\n\t\t\tfloat scale = float(rings) - 1.3;\r\n\t\t\tvec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\r\n\t\t\tvec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\r\n\t\t\tvec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\r\n\t\t\tvec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\r\n\t\t\tvec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\r\n\t\t\tvec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\r\n\r\n\t\t\tvec4  one = vec4( 1.0 );\r\n\r\n\t\t\tvec4 P = vec4((coords),vec2(scale, scale));\r\n\r\n\t\t\tvec4 dist = vec4(0.0);\r\n\t\t\tfloat inorout = -4.0;\r\n\r\n\t\t\tdist.x = dot( P, HS0 );\r\n\t\t\tdist.y = dot( P, HS1 );\r\n\t\t\tdist.z = dot( P, HS2 );\r\n\t\t\tdist.w = dot( P, HS3 );\r\n\r\n\t\t\tdist = smoothstep( -feather, feather, dist );\r\n\r\n\t\t\tinorout += dot( dist, one );\r\n\r\n\t\t\tdist.x = dot( P, HS4 );\r\n\t\t\tdist.y = HS5.w - abs( P.z );\r\n\r\n\t\t\tdist = smoothstep( -feather, feather, dist );\r\n\t\t\tinorout += dist.x;\r\n\r\n\t\t\treturn clamp( inorout, 0.0, 1.0 );\r\n\t\t}\r\n\r\n\t\tfloat bdepth(vec2 coords) {\r\n\t\t\t// Depth buffer blur\r\n\t\t\tfloat d = 0.0;\r\n\t\t\tfloat kernel[9];\r\n\t\t\tvec2 offset[9];\r\n\r\n\t\t\tvec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\r\n\r\n\t\t\toffset[0] = vec2(-wh.x,-wh.y);\r\n\t\t\toffset[1] = vec2( 0.0, -wh.y);\r\n\t\t\toffset[2] = vec2( wh.x -wh.y);\r\n\r\n\t\t\toffset[3] = vec2(-wh.x,  0.0);\r\n\t\t\toffset[4] = vec2( 0.0,   0.0);\r\n\t\t\toffset[5] = vec2( wh.x,  0.0);\r\n\r\n\t\t\toffset[6] = vec2(-wh.x, wh.y);\r\n\t\t\toffset[7] = vec2( 0.0,  wh.y);\r\n\t\t\toffset[8] = vec2( wh.x, wh.y);\r\n\r\n\t\t\tkernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\r\n\t\t\tkernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\r\n\t\t\tkernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\r\n\r\n\r\n\t\t\tfor( int i=0; i<9; i++ ) {\r\n\t\t\t\tfloat tmp = texture2D(tDepth, coords + offset[i]).r;\r\n\t\t\t\td += tmp * kernel[i];\r\n\t\t\t}\r\n\r\n\t\t\treturn d;\r\n\t\t}\r\n\r\n\r\n\t\tvec3 color(vec2 coords,float blur) {\r\n\t\t\t//processing the sample\r\n\r\n\t\t\tvec3 col = vec3(0.0);\r\n\t\t\tvec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\r\n\r\n\t\t\tcol.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\r\n\t\t\tcol.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\r\n\t\t\tcol.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\r\n\r\n\t\t\tvec3 lumcoeff = vec3(0.299,0.587,0.114);\r\n\t\t\tfloat lum = dot(col.rgb, lumcoeff);\r\n\t\t\tfloat thresh = max((lum-threshold)*gain, 0.0);\r\n\t\t\treturn col+mix(vec3(0.0),col,thresh*blur);\r\n\t\t}\r\n\r\n\t\tvec3 debugFocus(vec3 col, float blur, float depth) {\r\n\t\t\tfloat edge = 0.002*depth; //distance based edge smoothing\r\n\t\t\tfloat m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\r\n\t\t\tfloat e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\r\n\r\n\t\t\tcol = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\r\n\t\t\tcol = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\r\n\r\n\t\t\treturn col;\r\n\t\t}\r\n\r\n\t\tfloat linearize(float depth) {\r\n\t\t\treturn -zfar * znear / (depth * (zfar - znear) - zfar);\r\n\t\t}\r\n\r\n\t\tfloat vignette() {\r\n\t\t\tfloat dist = distance(vUv.xy, vec2(0.5,0.5));\r\n\t\t\tdist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\r\n\t\t\treturn clamp(dist,0.0,1.0);\r\n\t\t}\r\n\r\n\t\tfloat gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\r\n\t\t\tfloat rings2 = float(rings);\r\n\t\t\tfloat step = PI*2.0 / float(ringsamples);\r\n\t\t\tfloat pw = cos(j*step)*i;\r\n\t\t\tfloat ph = sin(j*step)*i;\r\n\t\t\tfloat p = 1.0;\r\n\t\t\tif (pentagon) {\r\n\t\t\t\tp = penta(vec2(pw,ph));\r\n\t\t\t}\r\n\t\t\tcol += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\r\n\t\t\treturn 1.0 * mix(1.0, i /rings2, bias) * p;\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\t\t\t//scene depth calculation\r\n\r\n\t\t\tfloat depth = linearize(texture2D(tDepth,vUv.xy).x);\r\n\r\n\t\t\t// Blur depth?\r\n\t\t\tif ( depthblur ) {\r\n\t\t\t\tdepth = linearize(bdepth(vUv.xy));\r\n\t\t\t}\r\n\r\n\t\t\t//focal plane calculation\r\n\r\n\t\t\tfloat fDepth = focalDepth;\r\n\r\n\t\t\tif (shaderFocus) {\r\n\r\n\t\t\t\tfDepth = linearize(texture2D(tDepth,focusCoords).x);\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// dof blur factor calculation\r\n\r\n\t\t\tfloat blur = 0.0;\r\n\r\n\t\t\tif (manualdof) {\r\n\t\t\t\tfloat a = depth-fDepth; // Focal plane\r\n\t\t\t\tfloat b = (a-fdofstart)/fdofdist; // Far DoF\r\n\t\t\t\tfloat c = (-a-ndofstart)/ndofdist; // Near Dof\r\n\t\t\t\tblur = (a>0.0) ? b : c;\r\n\t\t\t} else {\r\n\t\t\t\tfloat f = focalLength; // focal length in mm\r\n\t\t\t\tfloat d = fDepth*1000.0; // focal plane in mm\r\n\t\t\t\tfloat o = depth*1000.0; // depth in mm\r\n\r\n\t\t\t\tfloat a = (o*f)/(o-f);\r\n\t\t\t\tfloat b = (d*f)/(d-f);\r\n\t\t\t\tfloat c = (d-f)/(d*fstop*CoC);\r\n\r\n\t\t\t\tblur = abs(a-b)*c;\r\n\t\t\t}\r\n\r\n\t\t\tblur = clamp(blur,0.0,1.0);\r\n\r\n\t\t\t// calculation of pattern for dithering\r\n\r\n\t\t\tvec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\r\n\r\n\t\t\t// getting blur x and y step factor\r\n\r\n\t\t\tfloat w = (1.0/textureWidth)*blur*maxblur+noise.x;\r\n\t\t\tfloat h = (1.0/textureHeight)*blur*maxblur+noise.y;\r\n\r\n\t\t\t// calculation of final color\r\n\r\n\t\t\tvec3 col = vec3(0.0);\r\n\r\n\t\t\tif(blur < 0.05) {\r\n\t\t\t\t//some optimization thingy\r\n\t\t\t\tcol = texture2D(tColor, vUv.xy).rgb;\r\n\t\t\t} else {\r\n\t\t\t\tcol = texture2D(tColor, vUv.xy).rgb;\r\n\t\t\t\tfloat s = 1.0;\r\n\t\t\t\tint ringsamples;\r\n\r\n\t\t\t\tfor (int i = 1; i <= rings; i++) {\r\n\t\t\t\t\t/*unboxstart*/\r\n\t\t\t\t\tringsamples = i * samples;\r\n\r\n\t\t\t\t\tfor (int j = 0 ; j < maxringsamples ; j++) {\r\n\t\t\t\t\t\tif (j >= ringsamples) break;\r\n\t\t\t\t\t\ts += gather(float(i), float(j), ringsamples, col, w, h, blur);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/*unboxend*/\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcol /= s; //divide by sample count\r\n\t\t\t}\r\n\r\n\t\t\tif (showFocus) {\r\n\t\t\t\tcol = debugFocus(col, blur, depth);\r\n\t\t\t}\r\n\r\n\t\t\tif (vignetting) {\r\n\t\t\t\tcol *= vignette();\r\n\t\t\t}\r\n\r\n\t\t\tgl_FragColor.rgb = col;\r\n\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <colorspace_fragment>\r\n\t\t}`\r\n\r\n};\r\n\r\nconst BokehDepthShader = {\r\n\r\n\tname: 'BokehDepthShader',\r\n\r\n\tuniforms: {\r\n\r\n\t\t'mNear': { value: 1.0 },\r\n\t\t'mFar': { value: 1000.0 },\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying float vViewZDepth;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <begin_vertex>\r\n\t\t\t#include <project_vertex>\r\n\r\n\t\t\tvViewZDepth = - mvPosition.z;\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform float mNear;\r\n\t\tuniform float mFar;\r\n\r\n\t\tvarying float vViewZDepth;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\r\n\t\t\tgl_FragColor = vec4( vec3( color ), 1.0 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { BokehShader, BokehDepthShader };\r\n"],
  "mappings": "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",
  "names": []
}
